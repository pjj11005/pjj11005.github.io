---
layout: post
title: 구현 (Implementation)
description: 이것이 취업을 위한 코딩테스트다 with 파이썬 책을 참고하여 **구현**을 공부한 내용입니다.
sitemap: false
---

그리디와 비슷하게 코딩테스트 공부의 기초

* this unordered seed list will be replaced by the toc
{:toc}


## 피지컬로 승부 하기
- 머릿속에 있는 알고리즘을 소스 코드로 바꾸는 과정
- 모든 범위의 코딩 테스트 유형을 포함하는 개념
- 풀이를 떠올리기는 쉽지만, 소스 코드로 옮기기는 어렵다.

> - 완전 탐색: 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
> - 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행


## 고려할 메모리 제약사항
    
> 파이썬
> 
> - 직접 자료형 저장 필요 X, 매우 큰 수의 연산 지원,
> - 실수형 변수는 유효숫자에 따라 연산 결과가 다를 수 있음을 기억
> - 리스트의 크기 꼭 고려
> - 메모리 사용량 보다 더 적은 양의 메모리를 사용해야 하는 것 기억
> 
>   | 데이터의 개수(리스트의 길이) | 메모리 사용량 |
>   | --- | --- |
>   | 1000 | 약 4KB |
>   | 1000000 | 약 4MB |
>   | 10000000 | 약 40 MB |

## 채점 환경
- 파이썬은 C/C++에 비해 수행 시간이 2배정도 됨
- 파이썬 - `1초에 2000만번의 연산 수행한다고 가정`하면 문제 없다.
- ex) 시간제한 1초, 데이터 100만개 → 시간복잡도 O(NlogN)이내로 해결해야함

## 접근 방법
- 언어 별 비교

    |  | 구현 난이도 | 프로그램 실행 시간 |
    | --- | --- | --- |
    | 파이썬 | 쉬운 편 | 긴 편 |
    | PyPy | 쉬운 편 | 다소 짧은 편 |
    | C++ | 어려운 편 | 짧은 편 |

- PyPy3 Python보다 연산 속도 빠르다. (`대략 1초에 2000만 번에서 1억번 정도의 연산 처리`)
- PyPy3의 환경을 지원하면 활용하도록 하자

## 예제 풀이
- 예제 1: 왕실의 나이트

    1. 내 풀이
        
        1. 우선 x,y방향으로 이동 좌표 배열 생성
        
        1. 그 후, 반복문을 통해 나이트가 이동 가능할 때만 카운트
        
        ```python
        def solve(start_x,start_y):
        global count
        
        for i in range(8):
            nx,ny=start_x+dx[i],start_y+dy[i]
            if 0<=nx<8 and 0<=ny<8:
            count+=1
        
        start=input()
        start_x,start_y=int(start[1])-1,ord(start[0])-ord('a')
        dx=[2,2,-2,-2,-1,1,-1,1]
        dy=[-1,1,-1,1,2,2,-2,-2]
        count=0
        solve(start_x,start_y)
        print(count)
        ```
        
    2. 풀이를 본 후
        
        이동 좌표를 한번에 정의할 수도 있었다…
        
    3. 해결한 후
        
        기본적으로 좌표를 이동 시키면서 조건에 맞을 때만 카운트 해주면 되었다.
    


    


    
## **참고 문헌 및 사이트** 

- 이것이 취업을 위한 코딩테스트다 with 파이썬